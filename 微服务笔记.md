# **微服务**

## 1 nacos

docker中两个容器之间是相互隔离的，需要配置到同一个网络中才能进行通信

一、查看正在运行的容器及其对应镜像

```
docker ps
```

 二、查看所有容器（包括已停止的）

```
docker ps -a
```

三、查看本地所有镜像

```
docker images
```

把现有容器加入到同一个网络中

不用重启容器！可以直接连接：

```
docker network connect mynet mysql
docker network connect mynet nacos
```

创建一个自定义网络

```
docker network create mynet
```

改完后需要重启nacos

```
docker restart nacos
```

 运行多个配置  ，将其进行复制然后

![image-20251030101736298](C:\Users\20588\AppData\Roaming\Typora\typora-user-images\image-20251030101736298.png)

```java
@RequiredArgsConstructor
private final RestTemplate restTemplate;
在这个注释下  不需要用@Autowire就能实现注入
```

```java
    private void handleCartItems(List<CartVO> vos) {
        //TODO //获取商品id
        // 1.获取商品id
        Set<Long> itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());
        // 2.获取商品信息
        //2.1 根据服务名称获取服务的实例列表
        List<ServiceInstance> instances = discoveryClient.getInstances("item-service");
        if(CollUtils.isEmpty(instances)){
            return;
        }
        //2.2 手写负载均衡，从实例列表中选一个实例
        ServiceInstance instance = instances.get(RandomUtil.randomInt(instances.size()));


        // 2.查询商品
//        List<ItemDTO> items = itemService.queryItemByIds(itemIds);
        // 发送http请求
        ResponseEntity<List<ItemDTO>> response = restTemplate.exchange(
                instance.getUri() + "/item/?ids={ids}",
                HttpMethod.GET,
                null,
                new ParameterizedTypeReference<List<ItemDTO>>() {
                },
                Map.of("ids", CollUtils.join(itemIds, ","))


        );    //  .var  得到返回值

        if (!response.getStatusCode().is2xxSuccessful()) {
            return;

        }
        List<ItemDTO> items = response.getBody();
        if (CollUtils.isEmpty(items)) {
            return;
        }
        // 3.转为 map
        Map<Long, ItemDTO> itemMap = items.stream()
                .collect(Collectors.toMap(ItemDTO::getId, Function.identity()));
        // 4.写入vo
        for (CartVO v : vos) {
            ItemDTO item = itemMap.get(v.getItemId());
            if (item == null) {
                continue;
            }
            v.setNewPrice(item.getPrice());
            v.setStatus(item.getStatus());
            v.setStock(item.getStock());
        }

    }
```

![image-20251030105525097](C:\Users\20588\AppData\Roaming\Typora\typora-user-images\image-20251030105525097.png)

## 2 openfeign

1 引入依赖

```XML
  <!--openFeign-->
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-openfeign</artifactId>
  </dependency>
  <!--负载均衡器-->
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-loadbalancer</artifactId>
  </dependency>
```

2 启动openfeign

![image-20251030134143441](C:\Users\20588\AppData\Roaming\Typora\typora-user-images\image-20251030134143441.png)

3 编写openfeign客户端

```Java
package com.hmall.cart.client;

import com.hmall.cart.domain.dto.ItemDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.List;

@FeignClient("item-service")
public interface ItemClient {

    @GetMapping("/items")
    List<ItemDTO> queryItemByIds(@RequestParam("ids") Collection<Long> ids);
}
```

有了上述信息，OpenFeign就可以利用动态代理帮我们实现这个方法，并且向`http://item-service/items`发送一个`GET`请求，携带ids为请求参数，并自动将返回值处理为`List<ItemDTO>`。

我们只需要直接调用这个方法，即可实现远程调用了

4 最后，我们在`cart-service`的`com.hmall.cart.service.impl.CartServiceImpl`中改造代码，直接调用`ItemClient`的方法：

![img](https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=OTI5NGE0NzI4NmMyMjNiZDc4OTgxYzkzYjBjNWY2NzZfRjlvb1BvbDExSVVyYWQ3ZHBOaGw1QVJDaFlFVDlNY3hfVG9rZW46SGs3WGJBY2Q4bzdnOEt4eVRZaGNFQ3MybnNmXzE3NjE4MDgwODM6MTc2MTgxMTY4M19WNA)

## 3 docker

```Bash
docker run -d \
  --name mysql \
  -p 3306:3306 \
  -e TZ=Asia/Shanghai \
  -e MYSQL_ROOT_PASSWORD=@Wl20030313 \
  -v /root/mysql/data:/var/lib/mysql \
  -v /root/mysql/conf:/etc/mysql/conf.d \
  -v /root/mysql/init:/docker-entrypoint-initdb.d \
  --network mynet\
  mysql
```

## 4 网关

网关： 网络的关口，负责请求的路由的转发以及身份的校验。

![image-20251105160317466](C:\Users\20588\AppData\Roaming\Typora\typora-user-images\image-20251105160317466.png)

### Spring cloud gateway

![image-20251105160538301](C:\Users\20588\AppData\Roaming\Typora\typora-user-images\image-20251105160538301.png)

### Netfilx zuul

![image-20251105160546962](C:\Users\20588\AppData\Roaming\Typora\typora-user-images\image-20251105160546962.png)

路由规则的配置

![image-20251105194132300](C:\Users\20588\AppData\Roaming\Typora\typora-user-images\image-20251105194132300.png)

路由属性



# **hot100**

## 1 数组

1 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {

        Map<Integer,Integer> map=new HashMap<>();
        for (int i=0;i<nums.length;i++){
            if (map.containsKey(target-nums[i])){      //记清楚这个语句
                int[] a=new int[2];
                int s=map.get(target-nums[i]);
                
                return new int[]{s,i};
            }
            else
            {
                map.put(nums[i],i);
            }
        }
        throw new IllegalArgumentException("No two sum solution");
        
    }
}
```

2 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

 

**示例 1:**

**输入:** strs = ["eat", "tea", "tan", "ate", "nat", "bat"]

**输出:** [["bat"],["nat","tan"],["ate","eat","tea"]]

**解释：**

- 在 strs 中没有字符串可以通过重新排列来形成 `"bat"`。
- 字符串 `"nat"` 和 `"tan"` 是字母异位词，因为它们可以重新排列以形成彼此。
- 字符串 `"ate"` ，`"eat"` 和 `"tea"` 是字母异位词，因为它们可以重新排列以形成彼此。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<String, List<String>>();
        for (String str : strs) {
            char[] array = str.toCharArray();
            Arrays.sort(array);    
            String key = new String(array);
            // List<String> list = map.getOrDefault(key, new ArrayList<String>());
            List<String> list;
            if(map.containsKey(key)){
                list=map.get(key);
            }
            else{
                list=new ArrayList<>();
            }
            list.add(str);
            map.put(key, list);
        }
        return new ArrayList<List<String>>(map.values());
    }
}
//排序 根据排序信息确定是是唯一的
```

3 给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

 

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

**示例 3：**

```
输入：nums = [1,0,1,2]
输出：3
```

```java
class Solution {
    public int longestConsecutive(int[] nums) {

        Set<Integer> st=new HashSet<>();
        for (int num :nums){
            st.add(num);
        }
        int ans =0;

        for (int x:st){

            if (st.contains(x-1)){
                continue;
            }
            int y=x+1;
            while (st.contains(y)){
                y++;
            }
            ans=Math.max(ans,y-x);
        }
        return ans;
        
    }
}

//放入哈希表中处理，排序的复杂度太高了故舍弃
```

## 2 滑动窗口

4 给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

 

**示例 1：**

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

 

**提示：**

- `n == height.length`
- `2 <= n <= 105`
- `0 <= height[i] <= 104`

```java
class Solution {
    public int maxArea(int[] height) {
        int left=0;
        int right=height.length-1;
        int maxarea=0;
        while(left<right){
            int area=Math.min(height[left],height[right])*(right-left);

            maxarea=Math.max(area,maxarea);
            if (height[left]<height[right]){

                left++;
                

            }
            else{
                right--;
           
            }
        }
        return maxarea;
    }
}
```

5 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

 

 

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);  //数组直接排序------------------------------------需要记一下  容易忘记
        List<List<Integer>> res = new ArrayList<>();
        for(int k = 0; k < nums.length - 2; k++){
            if(nums[k] > 0) break;
            if(k > 0 && nums[k] == nums[k - 1]) continue;
            int i = k + 1, j = nums.length - 1;
            while (i < j) {
                int sum = nums[k] + nums[i] + nums[j];

                if (sum < 0) {
                    // 先把左指针前移一步（因为要寻找更大的数）
                    i++;
                    // 然后跳过与前一个相同的值（去重）
                    while (i < j && nums[i] == nums[i - 1]) {
                        i++;
                    }
                } else if (sum > 0) {
                    // 先把右指针后移一步（寻找更小的数）
                    j--;
                    // 跳过与后一个相同的值（去重）
                    while (i < j && nums[j] == nums[j + 1]) {
                        j--;
                    }
                } else {
                    // 记录结果
                    res.add(Arrays.asList(nums[k], nums[i], nums[j]));

                    // 同时前移左指针和后移右指针，并跳过重复值
                    i++;
                    j--;
                    while (i < j && nums[i] == nums[i - 1]) {
                        i++;
                    }
                    while (i < j && nums[j] == nums[j + 1]) {
                        j--;
                    }
                }
            }


        }
        return res;
    }
}


```

`s.charAt(i)` 是 **Java** 里的一个方法，用来**获取字符串 `s` 中下标为 `i` 的字符**。

- `s` 是一个 **String** 类型的变量（字符串）。
- `.charAt(i)` 会返回一个 **char 类型** 的结果。
- `i` 是一个 **整数索引**（从 0 开始计数）。

例如：

```java
java复制编辑String s = "Hello";
char c1 = s.charAt(0); // 'H'
char c2 = s.charAt(4); // 'o'
```

6 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长 子串** 的长度。

 

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
 
        int left=0;
        int ans=0;

        Set<Character> occ = new HashSet<Character>();
        
        for(int i=0;i<s.length();i++){
            while(occ.contains(s.charAt(i)))
            {
                occ.remove(s.charAt(left++));
            }
            occ.add(s.charAt(i));
            
            
            ans = Math.max(ans, i - left + 1);

        }
        return ans;
        
    }
}
```

6 给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

 

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

 **示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

 

**提示:**

- `1 <= s.length, p.length <= 3 * 104`
- `s` 和 `p` 仅包含小写字母

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> ans = new ArrayList<>();
        int[] cnts=new int[26];
        int[] cntp=new int[26];

        for (char c:p.toCharArray() ){  //_________字符串转换为数组
            cntp[c-'a']++;
        }
        for (int right=0;right<s.length();right++){
            cnts[s.charAt(right)-'a']++;

            int left=right-p.length()+1;

            if(left<0){
                continue;
            }
            if(Arrays.equals(cnts, cntp)){   //-------数组相等判断api
                ans.add(left);
            }
            cnts[s.charAt(left)-'a']--;
        }

        return ans;
    }
}
```

 Java 里，

- **`nums.length`**
  - 是一个**属性（field）**，不是方法。
  - 只能用于**数组**（例如 `int[] nums`、`String[] arr` 等）。

##  Java 长度/大小 获取速查表

| 数据类型 / 类                        | 获取方式        | 返回类型 | 说明                                 |
| ------------------------------------ | --------------- | -------- | ------------------------------------ |
| **数组** (`int[]`, `String[]`…)      | `arr.length`    | `int`    | **属性**，表示数组中元素个数，无括号 |
| **字符串** (`String`)                | `str.length()`  | `int`    | **方法**，返回字符串字符数           |
| **`ArrayList` / `List`**             | `list.size()`   | `int`    | **方法**，返回集合中元素个数         |
| **`HashMap` / `Map`**                | `map.size()`    | `int`    | **方法**，返回键值对数量             |
| **`HashSet` / `Set`**                | `set.size()`    | `int`    | **方法**，返回元素个数               |
| **`StringBuilder` / `StringBuffer`** | `sb.length()`   | `int`    | **方法**，返回当前字符数             |
| **`File`**                           | `file.length()` | `long`   | **方法**，返回文件字节大小           |
| **`CharSequence`**                   | `cs.length()`   | `int`    | **方法**，接口默认方法               |

7 给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

 

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        //前缀和  求出每一个前缀的和
        int l=nums.length;
        int[] s=new int[l+1];
        s[0]=0;
        for (int i=0;i<l;i++){
            s[i+1]=s[i]+nums[i];

            
        }

        int ans=0;
        Map<Integer,Integer> cnt=new HashMap<>();


        for (int  sj :s){
            if(cnt.containsKey(sj-k)){
                ans=cnt.get(sj-k)+ans;

            }
            else{
                ans=ans;
            }
            if(cnt.containsKey(sj)){
                cnt.put(sj,cnt.get(sj)+1);
            }
            else{
                cnt.put(sj,1);
            }
        }
        return ans;
        
    }
}
```

## 3 普通数组

7 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**是数组中的一个连续部分。

 

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [5,4,-1,7,8]
输出：23
```

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int l=nums.length;
        int sum=0;
        int i =0;
        int a=nums[0];
        while(i<l)
        {
            sum=sum+nums[i];

            if (sum>a){
                a=sum;
            }
            else{
                a=a;
            }
            i++;
            if (sum<=0){

                sum=0;

            }
        }
        return a;
    }
}
```

8  以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

 

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        
        if (intervals.length==0){
            return new int[0][2];
        }
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                return a[0]-b[0];
            }
        });
        List<int[]> merged = new ArrayList<int[]>();
        for (int i=0;i<intervals.length;i++){
            int l=intervals[i][0],r=intervals[i][1];
            if (merged.size()==0||merged.get(merged.size() - 1)[1] < l)
            { 
                merged.add(new int[]{l, r});                                             
            }
            else
            {
                 merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], r);
            }
        }
        return merged.toArray(new int[merged.size()][]);
    }
    
}
```



### 代码背景

通常在处理区间合并问题时，先用

```
java


复制编辑
Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
```

把区间按起点排序。然后用一个列表 `merged` 来保存合并结果。

------

### 逐行解释

```
java


复制编辑
for (int i = 0; i < intervals.length; i++) {
```

- 遍历所有区间。

------

```
java


复制编辑
int l = intervals[i][0], r = intervals[i][1];
```

- 当前区间的起点是 `l`，终点是 `r`。

------

```
java


复制编辑
if (merged.size() == 0 || merged.get(merged.size() - 1)[1] < l) {
```

- **`merged.size() == 0`**：如果结果列表还没有任何区间（第一个区间），直接放进去。
- **`merged.get(merged.size() - 1)[1] < l`**：如果当前区间的起点 `l` 大于结果列表中最后一个区间的终点（说明没有重叠），也直接放进去。

------

```
java


复制编辑
merged.add(new int[]{l, r});
```

- 如果没有重叠，就直接把当前区间 `{l, r}` 放入结果列表。

------

```
java复制编辑} else {
    merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], r);
}
```

- 否则说明有重叠（当前区间与 `merged` 的最后一个区间相交），就**合并**：
  - `merged.get(merged.size() - 1)[1]` 是最后一个区间的终点。
  - `Math.max(...)` 取两者的较大值，更新为新的终点。

------

```
java


复制编辑
return merged.toArray(new int[merged.size()][]);
```

- 把 `List<int[]>` 转成 `int[][]` 数组返回。

------

### 举个例子

假设：

```
java


复制编辑
intervals = [[1,3], [2,6], [8,10], [15,18]]
```

排序后：

```
lua


复制编辑
[[1,3], [2,6], [8,10], [15,18]]
```

合并过程：

1. merged = []
   加入 [1,3]
2. [2,6] 与 [1,3] 重叠，合并成 [1,6]
3. [8,10] 与 [1,6] 不重叠，加入 [8,10]
4. [15,18] 与 [8,10] 不重叠，加入 [15,18]

结果：

```
lua


复制编辑
[[1,6], [8,10], [15,18]]
```

如果你想创建一个**包含两个元素**的 `int[]` 数组（比如区间 `[l, r]`），应该用：

```
java


复制编辑
res.add(new int[]{l, r});
```

9 给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

 

**示例 1:**

```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

**示例 2:**

```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```

 给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。

 

**示例 1:**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2:**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

 题目思路：

当前字符左边的全部乘积，右边的全部乘积，两个相乘就是结果

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {

        int l=nums.length;
        int[] L=new int[l];
        int[] R=new int[l];
        
        L[0]=1;
        
        for(int i=1;i<l;i++){
            L[i]=L[i-1]*nums[i-1];
        }

        R[l-1]=1;
        for(int i=l-2;i>=0;i--){
            R[i]=nums[i+1]*R[i+1];
        }

        int[] ans=new int[l];

        for (int i=0;i<l;i++){



            ans[i]=L[i]*R[i];
        }
        return ans;
    }
}
```

10 给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

 

**示例 1：**

```
输入：nums = [1,2,0]
输出：3
解释：范围 [1,2] 中的数字都在数组中。
```

**示例 2：**

```
输入：nums = [3,4,-1,1]
输出：2
解释：1 在数组中，但 2 没有。
```

**示例 3：**

```
输入：nums = [7,8,9,11,12]
输出：1
解释：最小的正数 1 没有出现。
```

 

**提示：**

- `1 <= nums.length <= 105`
- `-231 <= nums[i] <= 231 - 1`

```java
class Solution {
    public int firstMissingPositive(int[] nums) {

        int len=nums.length;

        Set<Integer> hashSet=new HashSet<>();
        for (int num:nums){
            hashSet.add(num);
        }
        for (int i=1;i<=len;i++){
            if (!hashSet.contains(i)){
                return i;
            }
        }
        return len+1;
    }
}
```

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

根据题目示例 matrix = [[1,2,3],[4,5,6],[7,8,9]] 的对应输出 [1,2,3,6,9,8,7,4,5] 可以发现，顺时针打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。

因此，考虑设定矩阵的 “左、上、右、下” 四个边界，模拟以上矩阵遍历顺序。



算法流程：
空值处理： 当 matrix 为空时，直接返回空列表 [] 即可。
初始化： 矩阵 左、右、上、下 四个边界 l , r , t , b ，用于打印的结果列表 res 。
循环打印： “从左向右、从上向下、从右向左、从下向上” 四个方向循环打印。
根据边界打印，即将元素按顺序添加至列表 res 尾部。
边界向内收缩 1 （代表已被打印）。
判断边界是否相遇（是否打印完毕），若打印完毕则跳出。
返回值： 返回 res 即可。
打印方向	1. 根据边界打印	2. 边界向内收缩	3. 是否打印完毕
从左向右	左边界l ，右边界 r	上边界 t 加 1	是否 t > b
从上向下	上边界 t ，下边界b	右边界 r 减 1	是否 l > r
从右向左	右边界 r ，左边界l	下边界 b 减 1	是否 t > b
从下向上	下边界 b ，上边界t	左边界 l 加 1	是否 l > r





编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
```

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {


        int i=0;

        int j=matrix[0].length-1;
        while(i<matrix.length && j>=0){

            if (matrix[i][j]==target){
                return true;
            }
            if(matrix[i][j]<target){
                i++;
            }
            else{
                j--;
            }


        }
        return false;
        
    }
}
```

![lc240.png](https://pic.leetcode.cn/1716183468-zVwElx-lc240.png)

```java
//方法二
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        for (int[] row : matrix) {
            int index = search(row, target);
            if (index != -1) {
                return true;
            }
        }
        return false;
    }

    public int search(int[] nums, int target) {
        int l = 0;
        int r = nums.length - 1;
        
        while (l <= r) {
            int x = (r - l) / 2 + l;
            int num = nums[x];
            
            if (num == target) {
                return x;
            } else if (num > target) {
                r = x - 1;
            } else {
                l = x + 1;
            }
        }
        return -1;
    }
}
```



## 4 链表

判断两个链表是否相交

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**自定义评测：**

**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：

- `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`
- `listA` - 第一个链表
- `listB` - 第二个链表
- `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
- `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。

 

**示例 1：**

[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        Set<ListNode> visit=new HashSet<>();
        ListNode temp=headA;
        while(temp!=null){
            visit.add(temp);
            temp=temp.next;
        }
        temp=headB;
        while(temp!=null){
            if (visit.contains(temp)){
                return temp;
            }
            temp=temp.next;
        }
        return null;
        
    }
}

//哈希表 通过哈希表 判断是否出现链表的结点
```



反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {

        ListNode pre=null;
        ListNode cur=head;
        while(cur!=null){
            ListNode next=cur.next;
            cur.next=pre;
            pre=cur;
            cur=next;
        }

        return  pre;
        
    }
}
```

![image-20250820164528898](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250820164528898.png)

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

```
输入：head = [1,2,2,1]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)

```
输入：head = [1,2]
输出：false
```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode mid = middleNode(head);
        ListNode head2 = reverseList(mid);
        while (head2 != null) {
            if (head.val != head2.val) { // 不是回文链表
                return false;
            }
            head = head.next;
            head2 = head2.next;
        }
        return true;
    }

    private ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    private ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode nxt = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }
}


```





给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第 K 个节点、寻找环入口、寻找公共尾部入口等。

在本题的求解过程中，双指针会产生两次“相遇”。

双指针的第一次相遇：
设两指针 fast，slow 指向链表头部 head 。
令 fast 每轮走 2 步，slow 每轮走 1 步。
执行以上两步后，可能出现两种结果：

第一种结果： fast 指针走过链表末端，说明链表无环，此时直接返回 null。

如果链表存在环，则双指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 一定会追上 slow 。

第二种结果： 当fast == slow时， 两指针在环中第一次相遇。下面分析此时 fast 与 slow 走过的步数关系：

设链表共有 a+b 个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环 有 b 个节点（这里需要注意，a 和 b 是未知数，例如图解上链表 a=4 , b=5）；设两指针分别走了 f，s 步，则有：

fast 走的步数是 slow 步数的 2 倍，即 f=2s；（解析： fast 每轮走 2 步）
fast 比 slow 多走了 n 个环的长度，即 f=s+nb；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）。
将以上两式相减得到 f=2nb，s=nb，即 fast 和 slow 指针分别走了 2n，n 个环的周长。

接下来该怎么做呢？

如果让指针从链表头部一直向前走并统计步数k，那么所有 走到链表入口节点时的步数 是：k=a+nb ，即先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点。而目前 slow 指针走了 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。

但是我们不知道 a 的值，该怎么办？依然是使用双指针法。考虑构建一个指针，此指针需要有以下性质：此指针和 slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头节点head。

双指针第二次相遇：
令 fast 重新指向链表头部节点。此时 f=0，s=nb 。
slow 和 fast 同时每轮向前走 1 步。
当 fast 指针走到 f=a 步时，slow 指针走到 s=a+nb 步。此时两指针重合，并同时指向链表环入口，返回 slow 指向的节点即可。

根据：

1. f=2s （快指针每次2步，路程刚好2倍）
2. f = s + nb (相遇时，刚好多走了n圈）

推出：s = nb

从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。

如何知道slow刚好走了a步？ 从head开始，和slow指针一起走，相遇时刚好就是a步

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {


        Set<ListNode> visit =new HashSet<>();

        while (head!=null){
            if (visit.contains(head)){
                return true;
            }
            else{
                visit.add(head);
            }
            head=head.next;
        }
        return false;
    }
}
```

```java
//方法2 快慢指针
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}


```

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode a=new ListNode(0);
        ListNode cur=a;

        while(list1!=null && list2!=null){
            if(list1.val>list2.val){
                cur.next=list2;
                list2=list2.next;
            }
            else {
                cur.next=list1;
                list1=list1.next;
            }

            

            cur=cur.next;

        }

        while(list1!=null){
            cur.next=list1;
            list1=list1.next;
            cur=cur.next;
        }
        while(list2!=null){
            cur.next=list2;
            list2=list2.next;
            cur=cur.next;
        }

        return a.next;
        
    }
}
```

\max \frac{1}{T} \sum_{t=1}^{T} \sum_{\substack{-c \leq j \leq c \\ j \neq 0}} \log P(w_{t+j} \mid w_t)

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode pre=new ListNode(0);
        ListNode cur=pre;

        int carry=0;
        int sum=0;

        while(l1!=null || l2!=null){
            int x =  l1==null ? 0 :l1.val;
            int y = l2==null ? 0:l2.val;
            sum=x+y+carry;
            carry=sum/10;
            sum=sum%10;
            cur.next=new ListNode(sum);
            cur=cur.next;
            if(l1!=null){
                l1=l1.next;
            }
            if(l2!=null){
                l2=l2.next;
            }

        }
        if (carry!=0){
            cur.next=new ListNode(carry);
        }

        return pre.next;
        
    }
}
```

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode pre=new ListNode(0,head);
        ListNode l=pre;
        ListNode r=pre;
        while(n!=0){
            r=r.next;
            n--;
        }
        while(r.next!=null){
            l=l.next;
            r=r.next;

        }
           
        
        l.next=l.next.next;
        return pre.next;
        
    }
}
```

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {


        if(head==null || head.next==null){
            return head;
        }

        Stack<ListNode> stack =new Stack<ListNode>();    //栈的用法

        ListNode pre=new ListNode(0,head);
        ListNode cur=pre.next;
        ListNode p=pre;

        while(cur!=null && cur.next!=null){

            stack.add(cur);   //进栈
            stack.add(cur.next);

            cur=cur.next.next;
            p.next=stack.pop();  //出栈
            p=p.next;
            p.next=stack.pop();
            p=p.next;

            
        }
        if (cur!=null){
            p.next=cur;
        }
        else{
            p.next=null;
        }

        return pre.next;


     
        
    }
}


import java.util.ArrayDeque;
import java.util.Deque;

public class DequeAsStackExample {
    public static void main(String[] args) {
        // 使用 Deque 作为栈
        Deque<Integer> stack = new ArrayDeque<>();
        
        // 1. 压栈操作 (push) - 相当于 addFirst()
        System.out.println("压栈操作:");
        stack.push(10);
        System.out.println("压入: " + 10 + ", 栈内容: " + stack);
        
        stack.push(20);
        System.out.println("压入: " + 20 + ", 栈内容: " + stack);
        
        stack.push(30);
        System.out.println("压入: " + 30 + ", 栈内容: " + stack);
        
        // 2. 查看栈顶元素 (peek) - 相当于 peekFirst()
        System.out.println("\n查看栈顶元素: " + stack.peek());
        System.out.println("查看后栈内容: " + stack);
        
        // 3. 弹栈操作 (pop) - 相当于 removeFirst()
        System.out.println("\n弹栈操作:");
        System.out.println("弹出: " + stack.pop() + ", 栈内容: " + stack);
        System.out.println("弹出: " + stack.pop() + ", 栈内容: " + stack);
        
        // 4. 检查栈是否为空
        System.out.println("\n栈是否为空: " + stack.isEmpty());
        
        // 5. 再次弹栈
        System.out.println("弹出: " + stack.pop() + ", 栈内容: " + stack);
        System.out.println("栈是否为空: " + stack.isEmpty());
        
        // 6. 尝试在空栈上弹栈会抛出异常
        try {
            stack.pop();
        } catch (Exception e) {
            System.out.println("\n尝试在空栈上弹栈抛出异常: " + e.getClass().getSimpleName());
        }
        
        // 7. 使用其他方法实现相同功能
        System.out.println("\n使用其他Deque方法模拟栈操作:");
        Deque<String> anotherStack = new ArrayDeque<>();
        
        // 使用 addFirst() 代替 push()
        anotherStack.addFirst("第一");
        anotherStack.addFirst("第二");
        anotherStack.addFirst("第三");
        System.out.println("栈内容: " + anotherStack);
        
        // 使用 getFirst() 代替 peek()
        System.out.println("栈顶元素: " + anotherStack.getFirst());
        
        // 使用 removeFirst() 代替 pop()
        System.out.println("弹出: " + anotherStack.removeFirst());
        System.out.println("弹出后栈内容: " + anotherStack);
    }
}
```

当你用 `Deque` 模拟栈时，你必须一致地选择一端作为“栈顶”。有两个选择：

1. **将 Deque 的【头部】（First）作为栈顶** (更常见，也是 `Deque` 接口官方推荐的方式)
   - **压栈 (Push)**: 使用 `addFirst(e)` 或 `push(e)` ( `push` 方法默认就是加到头部 )。
   - **弹栈 (Pop)**: 使用 `removeFirst()` 或 `pop()` ( `pop` 方法默认就是从头部移除)。
   - **查看 (Peek)**: 使用 `getFirst()` 或 `peek()`。
2. **将 Deque 的【尾部】（Last）作为栈顶**
   - **压栈 (Push)**: 使用 `addLast(e)`。
   - **弹栈 (Pop)**: 使用 `removeLast()` 或 `pollLast()`。
   - **查看 (Peek)**: 使用 `getLast()` 或 `peekLast()`。

## 5 树

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

 

```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

**示例 2：**

```
输入：root = [1,null,2]
输出：2
```

 

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null){
            return 0;
        }

        List<TreeNode> queue=new LinkedList<>();
        queue.add(root);
        List<TreeNode> re=new LinkedList<>();

        int ans=0;

        while(!queue.isEmpty()){
            List<TreeNode> tmp=new LinkedList<>();

            for(TreeNode i: queue){

                if (i.left!=null){
                    tmp.add(i.left);
                }
                if (i.right!=null){
                    tmp.add(i.right);
                }
            }
            queue=tmp;
            ans++;

        }
        return ans;


        
    }
}//广度优先
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if (root==null){
            return 0;
        }
        
        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
        
        
    }
}//深度优先
```

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

**示例 2：**

```
输入：root = [1,2]
输出：1
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    private int ans=0;
    public int diameterOfBinaryTree(TreeNode root) {

        dfs(root);

        return ans;
        
    }

    private int dfs(TreeNode node){

        if (node==null){

            return -1;
        }

        int llen=dfs(node.left)+1;
        int rlen=dfs(node.right)+1;
        ans=Math.max(ans,llen+rlen);


        return Math.max(llen,rlen);
    }
}
```

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

```java
//两个d
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res=new ArrayList<List<Integer>>();
        if (root==null){
            return res;
        }
        List<TreeNode> ans=new ArrayList<>();
        ans.add(root);

        while(!ans.isEmpty()){
            List<TreeNode> nx=new ArrayList<>();
            List<Integer> vals = new ArrayList<>(); 

            for(TreeNode node: ans){
                vals.add(node.val);

                if (node.left!=null){
                    nx.add(node.left);
                }
                if(node.right!=null){
                    nx.add(node.right);
                }

            }
            ans=nx;
            res.add(vals);

        }
        return res;
        
    }
}
```

```java
//一个队列

class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) {
            return List.of();
        }
        List<List<Integer>> ans = new ArrayList<>();
        Queue<TreeNode> q = new ArrayDeque<>();
        q.add(root);
        while (!q.isEmpty()) {
            int n = q.size();
            List<Integer> vals = new ArrayList<>(n); // 预分配空间
            while (n-- > 0) {
                TreeNode node = q.poll();
                vals.add(node.val);
                if (node.left != null)  q.add(node.left);
                if (node.right != null) q.add(node.right);
            }
            ans.add(vals);
        }
        return ans;
    }
}


```

## 6 回溯算法

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

```java
在 Java 中，boolean[] 数组的默认值是 false。

也就是说，当你这样声明数组时：

boolean[] used = new boolean[5];
```

## 7 贪心算法

[376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

中等



相关标签

![premium lock icon](https://static.leetcode.cn/cn-frontendx-assets/production/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)相关企业



如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if (nums.length<=1){
            return nums.length;
        }
        int prec=0;
        int curc=0;
        int count=1;
        for (int i=1;i<nums.length;i++){
            curc=nums[i]-nums[i-1];
            if (curc>0&&prec<=0 || curc<0&&prec>=0){
                count++;
                prec=curc;
            }
        }
        return count;
    }
}

//贪心算法
```

[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

已解答

中等



相关标签

![premium lock icon](https://static.leetcode.cn/cn-frontendx-assets/production/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)相关企业



给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**是数组中的一个连续部分。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        
        int l=nums.length;
        if (l==1){
            return nums[0];
        }
        int a=0;
        int sum=Integer.MIN_VALUE;   //设置最小值用于比较 b
        for (int x=0;x<l;x++){
            a=a+nums[x];
            sum=Math.max(sum,a);
            if (a<0){
                a=0;
            }

        }
        return  sum;
    }
}
```

## 8 特殊技巧

[287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

中等



相关标签

![premium lock icon](https://static.leetcode.cn/cn-frontendx-assets/production/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)相关企业



给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

 

**示例 1：**

```
输入：nums = [1,3,4,2,2]
输出：2
```

**示例 2：**

```
输入：nums = [3,1,3,4,2]
输出：3
```

**示例 3 :**

```
输入：nums = [3,3,3,3,3]
输出：3
```

```java
技巧就是环形链表
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0;  // 慢指针，初始化为数组的第一个位置
        int fast = 0;  // 快指针，初始化为数组的第一个位置
        
        // 第一步：找出快慢指针相遇的点
        slow = nums[slow];  // 慢指针每次走一步
        fast = nums[nums[fast]];  // 快指针每次走两步
        
        // 当快慢指针没有相遇时，不断地让它们走
        while (slow != fast) {
            slow = nums[slow];  // 慢指针每次走一步
            fast = nums[nums[fast]];  // 快指针每次走两步
        }
        
        // 输出慢指针相遇的点（这是环的一个点）
        System.out.println("相遇点: " + slow);
        System.out.println("快指针位置: " + fast);
        
        // 第二步：找到环的入口点（即重复的数字）
        int pre1 = 0;   // 预先设定另一个指针，从数组的第一个位置开始
        int pre2 = slow; // 慢指针所在的位置即为环内相遇点
        
        // 让两个指针都向前走，直到它们相遇时，那个位置就是环的入口点
        while (pre1 != pre2) {
            pre1 = nums[pre1];  // pre1指针每次走一步
            pre2 = nums[pre2];  // pre2指针每次走一步
            
            // 输出当前的pre1和pre2位置，帮助调试
            System.out.println("pre1指针位置: " + pre1);
            System.out.println("pre2指针位置: " + pre2);
        }
        
        // 当pre1和pre2相遇时，返回该位置，即为重复的数字
        return pre1;
    }
}

```

